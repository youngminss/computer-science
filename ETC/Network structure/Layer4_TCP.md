# TCP

### 정의

**TCP(Transmission Control Protocol, 전송 제어 프로토콜)**

+ 연결 기반, 신뢰도가 높은 데이터 전송을 가능하게 한다.
+ 애플리케이션이 보낸 데이터를 그 형태 그대로 상대방에게 확실하게 전달할 수 있다.

### TCP 역할 & 기능

**TCP가 담당하는 것은 딱 !**

+ 서버가 송신할 때
+ 서버가 수신한 후, 애플리케이션에게 전달할 때

이고, 실질적인 상대 서버까지 전송하는 부분은 TCP 하위 계층인 IP에게 모두 위임

+ TCP에 의존하지 않고, IP 만으로도 통신 가능하지만, IP에는 데이터가 상대방에게 확실히 전달이 되었는지 확인하거나, 데이터가 도착한 순서를 확인할 기능이 없다. 

**예를들어**

+ IP 방식으로만 전송 === 일반 우편
	- 상대방에게 도착 잘 됬는지 모름, 조회 불가
	- 중간에 몇개의 우편이 분실 될수도 있음
	- 우편물이  상대방에게 도착해도, 여러 개의 우편을 보낸 경우, 순서대로 상대방에게 잘 간다는 보장이 없음

+ TCP + IP 방식 전송 === 택배
	- IP 방식으로만 전송하는 단점에 대해, 전부 커버, 모두 자동화
	- 여러개의 우편이어도, 자동으로 분할해주고, 순서도 지켜주고, 전송후에도, 전송이 잘 되었는지 확인도 해줌

**TCP 주요 기능**

+ 포트 번호를 이용한 데이터 전송
+ 연결 생성
+ 데이터 보증과 재전송 제어
+ 흐름 제어와 폭주 제어

### TCP 처리 흐름

**애플리케이션에 의해 기록된 데이터**

+ 소켓(Socket)에 기록된 데이터는 소켓 큐를 경우, 소켓 버퍼(메모리 영역)에서 처리된다.
+ 소켓 버퍼는, TCP 계층 이후, 하위계층인, IP계층, 이더넷계층까지 일련의 처리도 소켓 버퍼 내에서 이뤄짐

**세그먼트(Segment) : TCP에서 데이터의 단위**

+ 데이터가 기록된 소켓 + TCP 헤더(header)
+ 헤더에는, 도착지점의 포트번호, TCP 기능에 필요한 여러 정보가 기록되어 있음

![](https://media.geeksforgeeks.org/wp-content/uploads/TCPSegmentHeader-1.png)

**MSS(Maximum Segment Size) : 1 TCP 세그멘트로 전송할 수 있는 최대 데이터 크기**

+ 최종적으로 링크계층(Layer 1)을 통해 데이터를 전송하기 때문에, MSS는 링크 계층에서 전송할 수 있는 데이터의 최대 크기의 의존적
+ 참고로, 대부분의 환경에서 MSS는 기본적으로 1460Byte
+ 예를들어, 2000바이트 데이터를 TCP 세그먼트로 분리시
	- 세그먼트 1 = 1460 바이트 + TCP 헤더
	- 세그먼트 2 = 540바이트 + TCP 헤더
	
**MTU(Maximum Transfer Unit) : 링크 계층에서 전송할 수 있는 최대 데이터 크기**

![](https://sandilands.info/sgordon/images/wireshark-capture-2.png)

### 포트 번호를 이용한 데이터 전송

**TCP에서는 포트번호(port)를 사용해서, 어떤 애플리케이션에 데이터를 전달할지 판단**

+ TCP 포트 번호는 0 ~ 65535 (16비트 = 4바이트) 까지의 숫자를 사용함 

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbhQphC%2Fbtq1K3g95hy%2FgLZ4qbjRRT26NRkgxwC7W1%2Fimg.png)

### TCP 연결 생성

+ TCP는 연결형 프로토콜
+ 가상경로(버추얼 서킷)이라 불리는 연결을 생성

**포트를 리슨한다 (LISTEN)**

+ TCP가 통신을 시작하면, 수친 측(통신할 서버)에게 "지금부터 통신한다" 라고 연락한 후, "OK" 사인을 받으면 그때 처음 생성
+ 통신을 받으려면, 통신을 받는 애플리케이션 역시, 미리 통신 준비를 하고 있어야 함
+ 수신 측, 서버 프로세스는 자신의 OS에게 "포트 번호 OO 에게 통신 요청이 오면 나에게 연결해라"라고 부탁한다.
+ 수신 측 소켓은 자신이 지정한 포트 번호에 통신이 오는지 기다렸다 받는다.

**3-way handShaking**

![](https://www.mdpi.com/applsci/applsci-06-00358/article_deploy/html/images/applsci-06-00358-g001.png)

+ 통신 상대인 서버 측 OS에게 가상 경로를 열도록 의뢰
+ 서버 측에서, 리슨하고 있는 포트번호로 통신 요구가 온다. 문제가 없으면 열어도 된다는 응답을 한다.
+ 클라이언트 측도 확인했다는 메시지를 다시 하번 보내며, 이때 처음으로 통신용 가상 경로가 열린다.

**이 연결은 두 개의 소켓(클라이언트 - 서버)사이에 전용 회선이 있는 것처럼 통신한다.**

+ TCP 통신을 시작할 때, 단지 상대 서버에 포트 번호와 연결을 열어 달라고 부탁만 하는 것임 !! 
+ 실질적인 데이터 전송은 IP에 위임한다.
+ 실제 물리적인 경로가 막히거나, 통신 상대 서버가 갑작스런 장애로 전원이 꺼져도, 가상경로인 TCP 연결은 끊어지지 않는다.
+ 이러한 경우, 데이터가 전달이 되진 않지만, 애플리케이션이 OS에게 연결 절단 의뢰를 하거나, 통신  대상이 에러를 보내지 않는 이상 TCP 연결 자체는 계속 유지 중이다.
+ TCP는 Keep Alive 타이머 설정이 있어서, 기본적으로 설정한 시간(대부분 3600초)동안 통신이 없으면 통신 상대가 존재하는 게 맞는지, 확인용 데이터를 여러 번 전송한다. 반응이 있으면 연결 유지하고, 없으면, 연결을 닫아 버린다.

### 데이터 보증과 재전송 제어

연결 생성 후, 데이터 송수신이 시작된다.   
TCP는 데이터가 확실히 전달되도록 보증하는 기능이 있다.

확인 응답과 재전송에 의해 구현

**ACK**

+ 수신 측에서, TCP 세그먼트가 잘 도착했다면, 수신 측은 송신 측에게 잘 도착했다는 것을 알려야한다.
+ 이 때  반환하는 것을 ACK라고 한다.
+ 수친 측은, TCP 헤더에 ACK 관련 정보를 넣은 TCP 세그먼트를 반환한다.

**시퀀스 번호(Sequence)**

+ 데이터 순서를 보증하는 구조에 필요하다.
+ 이 역시, TCP 세그먼트 헤더에 기록된다.
+ 현재, 도착한 TCP 세그먼트가, 전체 전송 데이터 중 몇 번 바이트 째부터 시작하는 부분인지 가리킨다.

![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQOvSErDsakimqIvKS_3nwWP-YoCChpLm7SMA&usqp=CAU)

+ 수신 측에서는, 이 시퀀스 번호를 보고, 원래 순서대로 데이터를 조립해서, 원래 데이터 형태를 확인하는 것이다.

### TCP 재전송 제어

이런 순차적 재조립을 위해 수신 측에서는 ACK를 반환할 때, 다음에 필요한 TCP 세그먼트의 시퀀스 번호도 ACK 번호로 전달한다.

![](https://i.stack.imgur.com/ZPFr6m.png)

여기서, 송신 측은 ACK가 오지 않으면 재전송을 해야한다. **그럼 어느 시점에서 재전송을 할까 ?**

![](https://woovictory.github.io/img/error_flow_control_7.png)

**1. 타임아웃**

+ 일정 시간 내에 ACK가 돌아오지 않으면 재전송한다.

**2. 중복 ACK(Duplicate ACK)**

+ 송신 측에서 전달한 TCP 세그먼트가 전송 도중 사라졌다.
+ 수신 측에서는, 그런지도 모르고, 다음 TCP 세그먼트가 도착하지만, 도중에 사라진 세그먼트를 계속 요구하기 때문에, ACK에서는 아직 못받은 TCP 세그먼트의 시퀀스 번호를 보내달라고 말한다.
+ 이 과정이 3회 중복이 되면, 송신 측에서도 "아, 내가 3회 연속으로 받은 ACK에 해당하는 TCP 세그먼트가 어떠한 장애로 전달이 안됬구나...하고 해당 TCP세그먼트를 재전송한다.

### TCP 흐름제어(유량제어)

> 송신(클라이언트) - 수신(서버)간에 데이터를 주고 받을 때, 서로 간에 속도와 크기의 균형을 맞추는 작업

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb1uTN8%2Fbtq1KdYQPCE%2F2kWo5JzOq7cYrm55NQFFe0%2Fimg.png)

이렇게, 시퀀스 번호와 ACK를 이용한, 데이터를 보내고 ACK를 기다리는 처리를 반복하다 보면 아무래도 시간이 많이 소요된다. 그리고 이러한 방식은 동기처리방식이다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb6UVN7%2Fbtq1JANNJAb%2FxRqHd3VaIs7jbgqXsN9SJ0%2Fimg.png)


**윈도우**

> 동기로 통신을 하면 효울이 나쁘기 때문에 ACK를 기다리지 않고 전송하는 것이 좋다.

+ 사실, 송신 측은, ACK 번호가 돌아오기 전에, 이미 다음 시퀀스 번호를 전송하고 있다.
+ TCP는 어느 정도의 세크먼트 수라면, ACK를 기다리지 않고 전송하는데, 이를 윈도우라고 한다.
+ ACK를 기다리지 않고, 전송 가능한 데이터 크기를 윈도우 크기라고 한다.

윈도우는, **송신(폭주) 윈도우**, **수신 윈도우** 두 가지가 있다.

+ 기본적으로, 수신 측이, 폭주 윈도우 크기를 조정해서, 폭주 윈도우와 수신 윈도우 중에 작은 쪽을 송신 윈도우로 채택하고, 이 범위 내에서 ACK를 기다리지 않고 전송을 하는 것

**슬라이딩 윈도우(Sliding Window)**

+ 이렇게 미리, 다음 세그먼트를 ACK가 오기전에 보내다가, 이전에 보낸 세그먼트에 대한 ACK가 오면, 해당 TCP 세그먼트는 재전송할 필요가 없으니깐, 송신 용 소켓 버퍼에서 삭제하고, 송신 윈도우를 다음으로 이동한다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FQmJlv%2Fbtq1MrPDXIN%2FkwNwNurtRN8Ik4QIYH004K%2Fimg.png)

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FPYete%2Fbtq1JAUv60U%2Fxtw5BzdYDaWFRou6Vfrxpk%2Fimg.png)


**슬라이딩 윈도우 오류제어 방식 2가지**

**GBN ( Go-Back-N ) : 중간에 누락된 패키지가 있으면, 그 패킷부터 재전송한다.**

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbUXACz%2Fbtq1JWQDuXY%2FfvxB9yAdRdXHkadbvtEouk%2Fimg.png)

+ 서버 측은, 패킷을 순차적으로 받고 응답한다.
+ 잘 받았다는 응답이 Lost 손실될 수 있지만 괜찮다. 그 다음 패킷을 받으면 생략된 패킷은 받은 걸로 인지 한다.

+ 서버 측에서 패킷 순서에 맞지 않은 경우, 더 이상 요청을 받지 않고 무시한다. (discard)
+ 서버 측에선 순서에 맞는 패킷을 요청한다. (ACK)
+ 위에서 설명했지만, 클아이언트 측에서 보낸 패킷에 대한 ACK 또는 NAK 요청이 없으면, 타임아웃에 걸려 재전송한다.
+ 타임아웃 전에, 서버 측에서 3회 중복 ACK나 NAK을 보내서, 누락된 패킷을 받아낸다.


**Selective repeat :  서버 측에서 손실된 패킷만 송신 측에, 재요청하는 방식**

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbqMqwZ%2Fbtq1IRP3IIZ%2FKFEyK28TnpFLXRuACeZ4p0%2Fimg.jpg)

+ GBN과 달리 순차적이지 않아도, 버퍼에 저장해놓는다.
+ 버퍼는 순차적으로 처리한다. 중간에 빠진 패킷에 대해 버퍼 초기화가 되지 않고, 윈도우(버퍼)크기 만큼 저장한다.
+ 시랲한 요청은 타이머 작동 또는 버퍼 풀일 경우 인지하고 있다가 재요청 ACK를 보낸다.

### TCP 폭주제어

> 위에 흐름제어에서, 왜 송신 측 윈도우를 "폭주 윈도우"라고 부르는 것인가 ?

+ 송신 측 윈도우 크기는, 네트워크 폭주 상태(혼잡 상태)에 맞추어 변경시키기 때문이다.
+ 네트워크가 혼잡하면, 폭주 윈도우 크기를 작게 해서 전송 데이터 양을 줄인다.

![](https://media.vlpt.us/images/mu1616/post/2c04e199-90ee-4bc0-8fbe-174eb58583c3/image.png)

**슬로우 스타트(Slow Start)**

+ 폭주 윈도우 크기는 통신 시작 시 1 TCP 세그먼트로 설정된다.
+ 통신 문제가 없이 시작돼서 수신 측에 도착하면 ACK 반환 시마다 폭주 윈도우 크기를 2세크먼트, 4세그먼트 식으로 지수 함수적으로 늘려나간다.

이런 방식이기에, TCP는 주변에 영향을 주지 않도록 자중하는 프로토콜이다.

[참조문헌](https://brunch.co.kr/@lars/1)