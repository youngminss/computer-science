## 웹 데이터 흐름

### Contents

**요청**
- `클라이언트 PC -> 웹 서버까지`
- `웹 서버 -> AP 서버까지` 
- `AP 서버 -> DB 서버까지`

**반환**
- `AP서버 -> 웹 서버까지`
- `웹 서버 -> 클라이언트 PC 까지`

---

### 웹 데이터 흐름 (개략적)

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F9936B8375C46AD2320A3E5)

![전체흐름](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbfabuJ%2Fbtq03vTu8xT%2FeBLKoOJWtSR6fAilHh49Rk%2Fimg.png "flow")

### 1. 클라이언트 PC -> 웹 서버

#### 절차

+ 웹 브라우저가 요청을 발생시킨다.
+ `이름 해석`을 한다.
+ 웹 서버가 요청을 접수한다
+ 웹 서버가 `정적 콘텐츠`인지 `동적 콘텐츠`인지 판단한다.
	
	- 웹 서버에 프로세스(httpd)가 정적 콘텐츠인지, 동적 콘텐츠인지 판단한다.
	- 정적 콘텐츠(정보)는 보통 **디스크**로부터 읽는다.
	- 동적 콘텐츠(정보)는 **네트워크**를 경유해서 **다른 서버**에 요청을 보낸다.
	
+ 필요한 경로로 데이터에 액세스한다.

#### 추가설명

`이름해석`
+ 웹 브라우저는 데이터가 있는 서버가 어디에 있는지 알지 못함
+ 인터넷상의 주소는 `IP`라는 숫자로 표현되어있어 문자열인 `URL`과 `IP`를 연결시키지 않으면 통신이 안된다.
+ 먼저, 클라이언트 OS의 호스트명, IP 주소 변환 테이블을 참조한다.
+ 존재하지 않는 경우, 외부 DNS서버에 요청해서 받아온다.

![정적과 동적 페이지](https://gmlwjd9405.github.io/images/web/static-vs-dynamic.png)

![web server WAS(Web Application Server)](https://gmlwjd9405.github.io/images/web/webserver-vs-was1.png)

**웹 서버의 역할**
+ 클라이언트로부터 HTTP 요청에 대해 적절한 파일이나 콘텐츠 반환
+ HTTP는 이미지나 동영상 데이터 전송에도 이용되지만, 기본적으로는 **텍스트 데이터**다.

> 웹 서버에서는 HTTP를 처리할 수 있는 **httpd 프로세스**가 가동되고 있다.

**요청에 대한 대답 = HTML 같은 텍스트 데이터나 이미지, 동영상 등의 바이너리 데이터로 구성**

`정적 콘텐츠`
+ 실시간으로 변경할 필요 없는 데이터
+ 회사 로고 이미지 데이터 등
+ 데이터 갱신 빈도가 낮은 것은, 디스크에 저장하고, 요청 시 저장해 둔 내용을 HTTP를 통해 사용자 웹 브라우저로 반환

`동적 콘텐츠`
+ 높은 빈도로 변경되는 데이터
+ 은행 잔고 정보나, 최신 날씨 정보 데이터 등

> 정적 콘텐츠는 **웹 서버에**서 반환해주는 반면, 동적 콘텐츠는 웹 서버가 아닌 **AP 서버**가 HTML 파일을 동적으로 생성해서 웹 서버로 반환해준다. 웹 서버는 동적 콘텐츠 요청을 AP 서버에 던지고 결과만 기다린다.

---

### 2. 웹 서버 -> AP 서버

**절차**

+ 웹 서버로부터 요청이 도착
+ 스레드가 요청을 받고, 자신이 계산할 수 있느지, 아니면 DB 접속까지 필요한지를 판단
+ DB 접속이 필요하면, 연결 풀에 액세스
+ DB 서버에 요청을 던짐

> 동적 콘텐츠 요청에 대해, 아직 존재하지 않는 콘텐츠를 가능한 빨리 만들어 내는 것에, 역할이 AP 서버다.

**CGI(Common Gateway Interface)**
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F99296F355C46AD2329AB92)

+ 단순한 요청(ex. 1 + 1)은 애플리케이션상에서 계산가능해서, AP서버의 스레드가 계산 후 결과를 반환 
+ 그러나, **사용자 잔금 정보**같은  현실적으로 AP서버에서 관리하기 현실적으로 힘든, **대량의 데이터** 관리 목적은, DB 서버가 적합
+ 이런 경우, AP 서버의 스레드가 DB 서버에 질의, 그 결과를 HTML 등으로 정리해서 반환한다.
+ AP 서버가 DB 서버에 접속하려면, **드라이버**가 필요하다. 드라이버 뒷단이, DB로 가능 인터페이스로, 해당 DB 자체를 은폐하는 역할을 한다.

> **그러나, 웹 애플리케이션 요구 기능의 규모가 커지고, 복잡해짐에 따라, CGI도 문제에 직면했다.** 프로세스 성능이 너무 느렸던 거다. 그 쯤, 개발된 언어 자바..

**Java AP 서버의 JVM**
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F99F9463F5C46AD241F9825)

+ JVM도 하나의 거대한 프로세스
+ 서블릿(Servlet) : CGI처럼 새로운 프로세스를 매번 기동할 필요없고, 고속으로 작동한다는 이점, 동적 콘텐츠

> 또 다른 문제점 발생 = 서블릿 내에서 HTML을 만들어 보내는데, 서블릿 내에서 사용자 요청을 처리하느 명령어와 HTML이 섞이는 문제 발생

+ 그래서 고안 된것이, JSP(Java Server Pages)
+ JSP : HTML 코드 내에서, 동적으로 출력하고 싶은 부분을 <%, %>로 묶고, 그 안에 자바 코드를 적용할 수 있다.  ( 파이썬에서 jinja )

**DB 서버 이외 옵션**

> 데이터가 필요하면 DB 서버에 접속하는 것이 일반적이지만, 항상 효율적이라 할 수는 없다.

예를 들어, **우리나라 행정 경계 정보**는 자주 바뀌지 않는 데이터이다. 이는, 매번 DB에 질의할 필요가 없다.

+ 이렇게, 규모가 작고, 갱신 빈도가 낮은 정보는, 위에 JVM 내부에 `캐시`로 저장해 두었다, 반환하는 것이 오히려 좋다. (고속 처리)

+ 반대로, 규모가 큰 **정적 데이터 전송 시**에는 DB 서버 이외에 `CDN(Content Delivery Network)`이라 불리는 **데이터 전송 전용 서버**를 이용하는 경우도 있다.

	- CDN은 **대량의 데이터 전송**에 특화 된 것
	- 전 세계에 있는 데이터 복사본(캐시)을 배치하는 기술 + 병렬 기술을 활요해서 처리를 효율화 한다.

---

### 3. AP 서버 -> DB 서버

**절차**

+ AP 서버로부터 요청이 도착
+ 프로세스가 요청을 접수하고, **캐시**가 존재하는지 확인
+ 캐시에 없으면, 디스크에 액세스(**시스템 콜**)
+ 디스크가 데이터를 반환
	- 여기서의 디스크 또한, 대량의 데이터에 고속 액세스하기 위한 전용 **서버**이다.
+ 데이터를 캐시 형태로 저장한다.(이후를 생각)
+ 결과를 AP 서버로 반환

**DB**

> DB 서버에도 다양한 소프트웨어가 존재

+ `웹 계열 시스템` : **MySQL**, **PostgreSQL** 등
+ `기업용 시스템` : **Oracle DB**, **MS SQL Server** 등

> DB 서버는 **데이터 창고**이고, 관리 대상 데이터가 방대하기 때문에, **얼마나 효율적으로 액세스**하는가가 중요하다.

`인메모리(In-memory) DB` 

+ 디스크 사용 X, 모든 처리를 메모리 내에서 완료하는 구조, 고속화 실현 가능하다.

**DB 서버 동작방식**

+ DB 서버는, **여러 개의 프로세스**가 **역할을 분담**(AP 서버는, 개별 프로세스 독립적)
+ 예를 들어, SQL 요청받아, 데이터 처리(검색, 가공 등) 역할을 하는, **서버 프로세스**
+ 메모리상의 차이 정보를 관리하거나, 디스크에 반영하는 일을 하는 **LGWR,DBWR**같은 프로세스
+ 결과적으론, **분업**을 통해 처리를 `병렬화`해서, **처리량**을 향상시킬 수 있다.

---

### 4. AP 서버 -> 웹 서버

**절차**
+ DB 서버로부터 데이터 도착
	- [NIC, 네트워크 인터페이스 컨트롤러(네트워크 연결 하드웨어 장치)](https://ko.wikipedia.org/wiki/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4_%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC) 경유로 도착
+ **스레드**가 데이터를 가지고, 계산 등을 한 후에, **파일 데이터**를 생성한다.
+ 결과를 웹 서버로 반환

**가공 결과**

+ **텍스트 데이터** : HTML, XML 파일을 사용하는 것이 일반적
+ **동적 이미지 등의 바이너리 데이터**를 생성해서 반환하는 경우도 있다.
+ HTTP로 전송 가능한 데이터라면 어떤 형태든 상관 X

---

### 5. 웹 서버 -> 클라이언트 PC

> AP 서버에서 돌아온 데이터를 받아서, 웹 서버의 프로세스(httpd)가 PC의 웹 브라우저로 반환

**절차**

+ AP 서버로부터 데이터가 도착
+ 프로세스(httpd)는 받은 데이터를 그대로 반환
+ 결과가 웹 브라우저로 반환되고 화면에 표시된다.

**끝이다. 다만, 하나의 요청에 하나의 데이터가 반환하는 상황을 설명한 것이고, 일반적인 웹 페이지는 페이지 HTML 파일과, 다수의 이미지 파일 등이 있다.**

> 때문에, 복수의 요청으로 **분할**돼서 웹 서버에 도착하고, 각 요청별로 데이터를 반환한다.

---

### 정리

+ **프로세스**나 **스레드**가 요청을 받는다.
+ 도착한 요청을 파악하고, 필요에 따라 별도 서버로 요청을 보낸다.
+ 도착한 요청에 대해 응답한다.

> `요청 기반 아키텍처`이기 때문에, 기본적으로, 각 서버는 **문을 열고 기다리고 있는 상태**이다.

+ 어느정도 요청이 올지, 언제 올지, 실제 요청이 오기 전까지는 알 수 없다. (IT 인프라의 성능 문제 발생이유 중 하나)



